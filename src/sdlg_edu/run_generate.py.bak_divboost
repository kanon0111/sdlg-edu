import argparse, json, random, re, os
from typing import Dict, Any, List

# ---------- big vocab banks (combinatorial space > 10^9) ----------
NAMES = ["Liam","Olivia","Noah","Emma","Ava","Mason","Sophia","Isabella","Ethan","Mia","Lucas","Amelia","Harper","James","Emily",
"David","Chloe","Henry","Ella","Jack","Grace","Leo","Aria","Benjamin","Aiden","Elijah","Scarlett","Daniel","Hannah","Jacob",
"Victoria","Samuel","Layla","Andrew","Zoey","Michael","Nora","Joseph","Lily","Wyatt","Aurora","Matthew","Ellie","Luke","Abigail",
"Gabriel","Penelope","Owen","Hazel","Carter","Luna","Dylan","Madison","Isaac","Evelyn","Caleb","Naomi","Ryan","Avery","Nathan",
"Bella","Julian","Paisley","Adam","Alice","Connor","Maya","Aaron","Leah","Eli","Stella","Anthony","Violet","Christian","Lucy",
"Charles","Brooklyn","Thomas","Elena","Nicholas","Savannah","Hunter","Claire","Sofia","Logan","Daniela","Arthur","Ivy","Max","Nina"]

PLACES = ["Tokyo","London","New York","Sydney","Toronto","Seoul","Paris","Berlin","Barcelona","Singapore","Dublin","Vancouver",
"Osaka","Kyoto","Nagoya","Fukuoka","Sapporo","Los Angeles","San Francisco","Boston","Seattle","Austin","Chicago","Miami",
"Lisbon","Porto","Madrid","Valencia","Milan","Rome","Copenhagen","Stockholm","Helsinki","Zurich","Geneva","Vienna","Prague","Warsaw"]

OBJECTS = ["report","keys","project","ticket","presentation","proposal","email","device","document","package",
"assignment","meeting","dataset","article","draft","budget","contract","timeline","feature","module","test suite","release","poster"]

ADJ = ["important","urgent","draft","updated","final","initial","complex","simple","optional","internal","temporary","archived"]
ADVERBS = ["briefly","carefully","quickly","quietly","clearly","thoroughly","efficiently","politely","confidently","happily","formally","casually"]
TIME_PH = ["yesterday","today","last week","this morning","in March","in 2023","two days ago","recently","just now","at noon","late at night","on Monday"]
PUNCT = [".","!","?"]
NUMW = ["one","two","three","four","five","six","seven","eight","nine","ten"]
MODALS = ["can","could","may","might","must","should","would","has to","ought to","is going to"]

PP_VERBS = ["has already finished","has already taken","has already submitted","has already lost","has already found",
            "has already booked","has already delivered","has just completed","has recently updated","has never done","has often done","has not yet done"]
PAST_VERBS = ["finished","took","submitted","lost","found","booked","delivered","reviewed","completed","updated","started","checked","approved"]

# ---------- helper ----------
WORD_RE = re.compile(r"[A-Za-z]+")

def pick(r: random.Random, seq: List[str]): return r.choice(seq)

def make_sentence(r: random.Random, topic: str) -> str:
    """Generate a single illustrative sentence for generic_* with rich variation."""
    name = pick(r,NAMES); place = pick(r,PLACES); obj = pick(r,OBJECTS)
    adv = pick(r,ADVERBS); t = pick(r,TIME_PH); num = pick(r,NUMW); punct = pick(r,PUNCT)
    # schema pool
    schemas = [
        "{name} {adv} used {topic} in {place} with the {obj} {t} ({num}){punct}",
        "In {place}, {name} applied {topic} to the {obj} {adv} {t} ({num}){punct}",
        "The {obj} was handled by {name} using {topic} {adv} in {place} {t} ({num}){punct}",
        "{name} demonstrated {topic} on the {obj} in {place} {t} ({num}){punct}",
        "{name} {adv} showcased {topic} with the {obj} in {place} {t} ({num}){punct}",
        "While in {place}, {name} practiced {topic} on the {obj} {t} ({num}){punct}",
        "{name} combined {topic} and the {obj} in {place} {adv} {t} ({num}){punct}",
    ]
    s = pick(r, schemas).format(name=name, adv=adv, topic=topic, place=place, obj=obj, t=t, num=num, punct=punct)
    # optional negation / modality tail (small prob)
    if r.random() < 0.35:
        tail = f" {pick(r,MODALS)}"
        if r.random() < 0.5: tail = " not " + pick(r,MODALS) if not tail.startswith(" not") else tail
        s += f" (hint: {tail})"
    return s

# ---------- builders per pattern ----------
def build_generic(r: random.Random, idx: int, topic: str, pattern: str) -> Dict[str,Any]:
    q_templates = [
        "Write one sentence using the topic: {topic}.",
        "Create a single example sentence that uses {topic}.",
        "Give an example sentence demonstrating {topic}.",
        "Compose one natural sentence employing {topic}.",
        "Provide an illustrative sentence that applies {topic}.",
        "Produce exactly one sentence that showcases {topic}.",
        "Write a concise sentence (~{n} words) using {topic}."
    ]
    q = pick(r, q_templates).format(topic=topic, n=r.randint(8,16))
    a = make_sentence(r, topic)
    return {
        "question_en": q,
        "answer_en": a,
        "explanation_ja": "主語・場所・対象・副詞・時相・数・モダリティなどを可変化。",
        "id": f"GRAM-{idx:06d}",
        "topic": topic,
        "pattern": pattern,
        "difficulty": pick(r, ["EASY","MEDIUM","HARD"]),
        "source": "synthetic/local"
    }

def build_pp_vs_past(r: random.Random, idx: int, topic: str, pattern: str) -> Dict[str,Any]:
    subj=pick(r,NAMES); obj=pick(r,OBJECTS); adj=pick(r,ADJ); place=pick(r,PLACES)
    year=r.randint(2012,2025)
    ppv=pick(r,PP_VERBS); pst=pick(r,PAST_VERBS)
    q_opts=[
        "How does '{s} {pp} the {a} {o}' differ from '{s} {ps} the {a} {o} in {y}' in {p}?",
        "Explain the difference between '{s} {pp} the {a} {o}' and '{s} {ps} the {a} {o} in {y}' (context: {p}).",
        "Compare: '{s} {pp} the {a} {o}' vs. '{s} {ps} the {a} {o} in {y}'. What is the nuance in {p}?",
        "In meaning and use, how is '{s} {pp} the {a} {o}' different from '{s} {ps} the {a} {o} in {y}' (place: {p})?"
    ]
    q = pick(r,q_opts).format(s=subj, pp=ppv, ps=pst, a=adj, o=obj, y=year, p=place)
    a_opts=[
        "Present perfect ties results/experience to now; simple past sits at a finished time.",
        "Present perfect shows present relevance; simple past is detached from the present.",
        "Present perfect links past to now; simple past marks a completed time point.",
        "Present perfect emphasizes now-oriented results; simple past describes a past-only event."
    ]
    a = pick(r,a_opts) + f" (loc: {place})"
    return {
        "question_en": q,
        "answer_en": a,
        "explanation_ja": "現在完了は現在への関連／過去形は完了済み時点。",
        "id": f"GRAM-{idx:06d}",
        "topic": topic,
        "pattern": pattern,
        "difficulty": pick(r, ["EASY","MEDIUM","HARD"]),
        "source": "synthetic/local"
    }

def build_article(r: random.Random, idx: int, topic: str, pattern: str) -> Dict[str,Any]:
    noun_pool = ["apple","umbrella","university","hour","cat","notebook","ocean","house","airport","ring","email","idea","user","error","engineer","orange"]
    templates = [
        "Please hand me __ {noun}.",
        "I bought __ {noun} yesterday.",
        "Close __ door, please.",
        "She is __ engineer in {place}.",
        "He needs __ {noun} for the project.",
        "They opened __ {noun} during the event.",
        "I saw __ {noun} at the station."
    ]
    noun = pick(r, noun_pool)
    phr = pick(r, templates).format(noun=noun, place=pick(r,PLACES))
    q_templates = [
        "Select the appropriate article: '{phr}'{p}",
        "Choose the correct article to complete: '{phr}'{p}",
        "Fill in the blank with the best article: '{phr}'{p}",
        "Which article fits best in: '{phr}'{p}"
    ]
    q = pick(r, q_templates).format(phr=phr, p=pick(r,PUNCT))
    if noun in ["apple","umbrella","ocean","hour","airport","idea","orange"]:
        ans = "Answer: an"
    elif " door" in phr or " the " in phr.lower():
        ans = "Answer: the"
    elif noun in ["university","house","cat","notebook","ring","user","error","email","engineer"]:
        ans = "Answer: a"
    else:
        ans = "Answer: (no article)"
    return {
        "question_en": q,
        "answer_en": ans,
        "explanation_ja": "母音音は an、子音音は a、特定は the、一般は無冠詞。",
        "id": f"GRAM-{idx:06d}",
        "topic": "articles (a/an/the/zero)",
        "pattern": pattern,
        "difficulty": pick(r, ["EASY","MEDIUM"]),
        "source": "synthetic/local"
    }

# ---------- main ----------
def build_item(r: random.Random, idx: int, topic: str, pattern: str) -> Dict[str,Any]:
    if pattern == "contrast_present_perfect_vs_past":
        return build_pp_vs_past(r, idx, topic, pattern)
    if pattern == "choose_correct_article":
        return build_article(r, idx, topic, pattern)
    if pattern.startswith("generic_"):
        return build_generic(r, idx, topic, pattern)
    # fallback
    return build_generic(r, idx, topic, pattern)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--recipe", required=True)
    ap.add_argument("--seed", type=int, default=42)
    ap.add_argument("--deterministic", action="store_true")
    ap.add_argument("--outdir", required=True)
    ap.add_argument("--n-per-topic", type=int, default=100)
    args = ap.parse_args()

    r = random.Random(args.seed)
    os.makedirs(args.outdir, exist_ok=True)
    out_path = os.path.join(args.outdir, "english_grammar_qa.jsonl")

    # read recipe (jsonl lines with keys: topic, pattern)
    recipe: List[Dict[str,str]] = []
    with open(args.recipe, "r", encoding="utf-8") as rf:
        for line in rf:
            line=line.strip()
            if not line: continue
            obj=json.loads(line)
            recipe.append(obj)

    idx = 1
    kept = 0
    with open(out_path, "w", encoding="utf-8") as wf:
        for spec in recipe:
            for _ in range(args.n_per_topic):
                item = build_item(r, idx, spec["topic"], spec["pattern"])
                wf.write(json.dumps(item, ensure_ascii=False)+"\n")
                idx += 1; kept += 1

    print(f"Saved: {out_path}  ({kept} rows)")
    print(f"Recipe lines: {len(recipe)} | per-topic: {args.n_per_topic}")

if __name__ == "__main__":
    main()
